#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>

using namespace std;

// Funcție care verifică dacă un șir dat poate fi generat de o gramatică liberă de context dată (CFG)
bool cyk(const string &s, const vector<tuple<char, string>> &rules) {
    int n = s.size(); // Obține lungimea șirului de intrare
    int r = rules.size(); // Obține numărul de reguli de producție

    // Creează o tabelă 2D pentru a stoca rezultatele subproblemelor
    vector<vector<set<char>>> dp(n, vector<set<char>>(n));

    // Inițializează tabela cu cazurile de bază
    for (int i = 0; i < n; i++) {
        for (const auto &rule : rules) {
            char A; // Non-terminalul din stânga
            string rhs; // Partea dreaptă a producției
            tie(A, rhs) = rule; // Despachetează regula
            if (rhs.size() == 1 && rhs[0] == s[i]) { // Dacă partea dreaptă a regulii este un terminal care se potrivește cu caracterul de intrare
                dp[i][i].insert(A); // Adaugă non-terminalul în tabela DP
            }
        }
    }

    // Completează tabela folosind abordarea de jos în sus
    for (int len = 2; len <= n; len++) { // Parcurge toate lungimile de la 2 la n
        for (int i = 0; i <= n - len; i++) { // Parcurge toate pozițiile de start
            int j = i + len - 1; // Calculează poziția de final
            for (int k = i; k < j; k++) { // Împarte subșirul în două părți
                for (const auto &rule : rules) {
                    char A; // Non-terminalul din stânga
                    string rhs; // Partea dreaptă a producției
                    tie(A, rhs) = rule; // Despachetează regula
                    if (rhs.size() == 2 && dp[i][k].count(rhs[0]) && dp[k + 1][j].count(rhs[1])) { // Verifică dacă regula poate fi aplicată
                        dp[i][j].insert(A); // Adaugă non-terminalul în tabela DP
                    }
                }
            }
        }
    }

    // Verifică dacă simbolul de start 'S' este în mulțimea de simboluri care pot genera întregul șir
    return dp[0][n - 1].count('S');
}

int main() {
    // Definim gramatica liberă de context în forma normală Chomsky (CNF)
    // Fiecare regulă este un tuplu în care primul element este non-terminalul din stânga
    // și al doilea element este partea dreaptă a producției
    vector<tuple<char, string>> rules = {
            {'S', "AB"},
            {'S', "BC"},
            {'A', "BA"},
            {'A', "a"},
            {'B', "CC"},
            {'B', "b"},
            {'C', "AB"},
            {'C', "a"}
    };

    //string input = "abba";// Șirul de intrare care trebuie verificat si nu e bun
    string input ="baaba";//// Șirul de intrare care trebuie verificat si e bun
    cout << "Input string: " << input << endl; // Afișează șirul de intrare

    if (cyk(input, rules)) { // Apelează funcția CYK
        cout << "The string can be generated by the given CFG." << endl; // Dacă CYK returnează true
    } else {
        cout << "The string cannot be generated by the given CFG." << endl; // Dacă CYK returnează false
    }

    return 0;
}
